# [01. OpenGL](https://learnopengl.com/Getting-started/OpenGL)

우리의 여정을 시작하기 전에, 먼저 OpenGL이 무엇인지 정의해 봅시다. OpenGL은 주로 API(Application Programming Interface, 응용 프로그램 프로그래밍 인터페이스)로 간주됩니다. 이는 그래픽과 이미지를 조작할 수 있도록 다양한 기능들을 제공하는 도구입니다. 그러나 사실 OpenGL 자체는 API가 아니라, Khronos Group이라는 단체에서 개발하고 유지 관리하는 **명세(specification)**입니다.

OpenGL 명세는 각 기능의 결과가 무엇이어야 하고, 어떻게 동작해야 하는지를 정확히 정의합니다. 그리고 이 명세에 따라 실제로 동작하는 기능을 구현하는 것은 개발자들의 몫입니다. OpenGL 명세는 구체적인 구현 방법을 제공하지 않기 때문에, 실제로 개발되는 OpenGL 버전들은 내부 구현 방식이 서로 달라도 상관없습니다. 다만, 결과물은 명세에 따라 동일해야 하며, 사용자 입장에서는 같은 결과를 얻을 수 있어야 합니다.

![](Img/2025-04-03-07-10-25.png)

실제로 OpenGL 라이브러리를 개발하는 사람들은 주로 그래픽 카드 제조사들입니다. 우리가 구매하는 그래픽 카드는 각각 특정 버전의 OpenGL을 지원하는데, 이는 해당 카드(시리즈)를 위해 특별히 개발된 OpenGL 버전들입니다. macOS 같은 애플 시스템에서는 OpenGL 라이브러리를 Apple 자체에서 관리하며, Linux에서는 그래픽 카드 제조사들이 만든 버전과 취미 개발자들이 수정한 버전이 혼합되어 제공되기도 합니다.
따라서 OpenGL이 정상적이지 않은 이상한 동작을 보일 경우, 이는 대부분 그래픽 카드 제조사(혹은 해당 라이브러리를 개발하거나 유지 보수한 사람들)의 문제인 경우가 많습니다.

> 대부분의 OpenGL 구현체가 그래픽 카드 제조사에 의해 만들어지기 때문에, 구현체에 버그가 있을 경우 일반적으로 그래픽 카드 드라이버를 업데이트하여 해결할 수 있습니다. 드라이버 안에 해당 카드가 지원하는 최신 OpenGL 버전이 포함되어 있기 때문입니다.
이것이 바로 그래픽 카드 드라이버를 주기적으로 업데이트하라고 권장하는 이유 중 하나입니다.

Khronos Group는 모든 OpenGL 버전의 **명세 문서(specification documents)**를 공개적으로 제공하고 있습니다. 관심 있는 독자라면 우리가 사용할 버전인 OpenGL 3.3의 명세서를 [여기](https://www.opengl.org/registry/doc/glspec33.core.20100311.withchanges.pdf)에서 찾아볼 수 있습니다.
이 명세서는 OpenGL의 세부 사항까지 깊이 있게 알고 싶다면 읽어볼 만한 좋은 자료입니다. (명세서에서는 대부분 구현 방법이 아닌 결과에 대해서만 설명하고 있다는 점에 주목해 보세요.)
또한 OpenGL 명세서는 각 함수가 정확히 어떻게 동작하는지를 찾아볼 수 있는 훌륭한 참고 자료가 되기도 합니다.

## Core-profile vs Immediate mode

과거에는 OpenGL을 사용한다는 것은 Immediate Mode(즉시 모드, 종종 Fixed Function Pipeline이라고도 불림)로 개발하는 것을 의미했습니다. 이것은 그래픽을 그리는 데 있어 사용하기 쉬운 방식이었습니다. 당시 대부분의 OpenGL 기능은 라이브러리 내부에 숨겨져 있었고, 개발자들은 OpenGL이 어떻게 계산을 수행하는지에 대해 크게 제어할 수 없었습니다.
그러나 시간이 지나면서 개발자들은 더 많은 유연성을 원하게 되었고, 이에 따라 OpenGL 명세도 점차 유연해지면서 개발자들에게 더 많은 제어권을 제공하게 되었습니다.
즉시 모드는 배우고 사용하기는 매우 쉬웠지만, 성능 면에서는 매우 비효율적이었습니다.
그래서 OpenGL 명세는 버전 3.2부터 즉시 모드 기능을 더 이상 사용하지 않도록(deprecate) 정리하기 시작했고, 대신 Core Profile 모드에서 개발할 것을 권장했습니다. Core Profile은 이전의 낡은 기능들을 제거한 명세 버전입니다.

Core Profile 모드를 사용할 경우, OpenGL은 개발자에게 최신 방식을 강제합니다.
만약 예전 방식의 함수(Deprecated Function)를 사용하면, OpenGL은 에러를 발생시키고 렌더링을 중단합니다.
최신 방식을 배우는 장점은, 무엇보다도 유연하고 효율적이라는 것입니다. 하지만 동시에 배우기 더 어렵다는 단점도 있습니다.
기존의 즉시 모드는 OpenGL 내부에서 어떤 일이 일어나는지를 많이 추상화했기 때문에, 배우기는 쉬웠지만 OpenGL이 실제로 어떻게 동작하는지 이해하기는 어려웠습니다.
반면, 최신 방식은 개발자가 OpenGL과 그래픽 프로그래밍 자체를 제대로 이해하도록 요구합니다.
비록 배우는 과정은 다소 어렵지만, 그만큼 훨씬 더 많은 유연성, 효율성, 그리고 무엇보다도 그래픽 프로그래밍에 대한 깊은 이해를 얻게 됩니다.

이것이 바로 이 책이 Core Profile 기반의 OpenGL 3.3 버전을 대상으로 작성된 이유이기도 합니다.
비록 학습 난이도가 더 높지만, 그만한 가치가 충분히 있기 때문입니다.

현재 시점에서는 OpenGL의 더 높은 버전들도 존재합니다. (이 글을 작성할 당시에는 4.6 버전까지 출시되어 있습니다.)
그러면 이런 질문이 생길 수 있습니다.
"최신 버전인 OpenGL 4.6이 있는데, 왜 굳이 3.3 버전을 배워야 하지?"
이에 대한 답은 의외로 간단합니다.
OpenGL 3.3 이후의 모든 버전은, 핵심 동작 방식(core mechanics)을 바꾸지 않은 채로 기능들이 추가되었을 뿐입니다.
즉, 최신 버전에서는 동일한 작업을 더 효율적이거나 더 편리하게 수행할 수 있는 기능이 추가되었지만, 핵심 개념과 기술은 그대로 유지되고 있습니다.

결과적으로, Modern OpenGL의 모든 핵심 개념과 기술은 3.3 버전부터 일관되게 유지되고 있기 때문에, OpenGL 3.3을 배우는 것은 전혀 문제가 없습니다.
그리고 충분히 실력을 쌓고 준비가 되었을 때, 필요한 기능만 최신 버전에서 선택적으로 사용하면 됩니다.

> 가장 최신 버전의 OpenGL 기능을 사용할 경우, 최신 그래픽 카드에서만 해당 애플리케이션을 실행할 수 있습니다.
이것이 대부분의 개발자들이 보통 낮은 버전의 OpenGL을 기본 대상으로 삼고, 필요에 따라 더 높은 버전의 기능을 선택적으로 활성화하는 이유이기도 합니다.

이 책의 일부 챕터에서는 더 최신 기능들을 다루고 있으며, 그런 경우에는 해당 기능임을 명확히 표시해 두었습니다.

## Extensions

OpenGL의 훌륭한 기능 중 하나는 **확장 기능(Extensions)**을 지원한다는 점입니다.
그래픽 카드 제조사들이 새로운 기술이나 렌더링 최적화 방법을 개발하면, 이는 종종 드라이버에 구현된 확장 기능의 형태로 제공됩니다.
애플리케이션이 실행되는 하드웨어가 해당 확장 기능을 지원할 경우, 개발자는 그 기능을 활용해 더 고급스럽거나 효율적인 그래픽을 구현할 수 있습니다.
덕분에 그래픽 개발자는 OpenGL의 정식 버전에 해당 기능이 추가되기를 기다릴 필요 없이, 그래픽 카드가 해당 확장을 지원하는지만 확인하면 바로 새로운 렌더링 기술을 사용할 수 있습니다.

그리고 어떤 확장 기능이 특히 인기 있고 유용할 경우, 미래의 OpenGL 버전에 공식적으로 포함되기도 합니다.

다만, 개발자는 이런 확장 기능을 사용하기 전에 해당 확장이 사용 가능한지 직접 확인하거나(OpenGL 쿼리 사용), OpenGL 확장 라이브러리를 사용해야 합니다.
이를 통해, 확장 기능의 지원 여부에 따라 더 나은 방법이나 더 효율적인 방법으로 작업할 수 있게 됩니다.

```CPP
if(GL_ARB_extension_name)
{
    // Do cool new and modern stuff supported by hardware
}
else
{
    // Extension not supported: do it the old way
}
```

참고로, OpenGL 3.3 버전에서는 대부분의 기술에 대해 확장 기능이 필요하지 않으며,
필요한 경우에는 이 책에서 적절한 사용 방법을 안내하고 있습니다.

## State machine

OpenGL은 그 자체로 **거대한 상태 머신(state machine)**이라고 할 수 있습니다.
즉, OpenGL이 현재 어떻게 동작해야 하는지를 정의하는 변수들의 집합입니다.
OpenGL의 이러한 상태를 흔히 **OpenGL 컨텍스트(Context)**라고 부릅니다.
OpenGL을 사용할 때 우리는 자주 옵션을 설정하거나, 버퍼를 조작하거나 하면서 이 상태를 변경하고, 그 상태에 기반해 렌더링을 수행하게 됩니다.

예를 들어, 우리가 OpenGL에게 삼각형 대신 선(Line)을 그리라고 지시하면,
OpenGL의 컨텍스트 내 특정 변수를 변경하게 되고, 이로 인해 **OpenGL의 상태(state)**가 바뀝니다.
그리고 상태가 변경된 이후, 다음에 호출하는 그리기 명령어들은 삼각형이 아니라 선을 그리게 됩니다.

OpenGL로 작업할 때 우리는 크게 두 종류의 함수를 접하게 됩니다.
하나는 상태를 변경하는 함수들이고, 다른 하나는 현재 상태를 기반으로 동작하는 함수들입니다.
OpenGL을 하나의 커다란 상태 머신이라고 생각하면,
OpenGL의 많은 기능들이 왜 그렇게 동작하는지 쉽게 이해할 수 있을 것입니다.

## Objects

OpenGL 라이브러리는 C 언어로 작성되어 있으며, 다른 여러 언어에서도 파생되어 사용할 수 있지만, 핵심은 C 라이브러리입니다.
그러나 C 언어의 많은 구조들이 상위 레벨 언어로는 잘 번역되지 않는 경우가 많기 때문에,
OpenGL은 처음부터 몇 가지 추상화 개념을 고려하여 개발되었습니다.
그 중 하나가 바로 **OpenGL의 객체(Object)**입니다.

OpenGL에서 객체란, OpenGL 상태의 **일부분(subset)**을 표현하는 옵션들의 집합입니다.
예를 들어, 그리기 창의 설정을 나타내는 객체가 있을 수 있습니다.
이 객체를 통해 창의 크기, 지원하는 색상 수 등 여러 옵션들을 설정할 수 있습니다.
쉽게 말해, 객체는 **C 언어의 구조체(struct)**와 비슷하게 생각할 수 있습니다.

```CPP
struct object_name {
    float  option1;
    int    option2;
    char[] name;
};
```

일반적으로 OpenGL에서 객체를 사용할 때는 다음과 같은 형태로 작업합니다.
(여기서 OpenGL의 컨텍스트는 **거대한 구조체(struct)**로 시각화할 수 있습니다.)

```CPP
// The State of OpenGL
struct OpenGL_Context {
  	...
  	object_name* object_Window_Target;
  	...  	
};
```

```CPP
// create object
unsigned int objectId = 0;
glGenObject(1, &objectId);
// bind/assign object to context
glBindObject(GL_WINDOW_TARGET, objectId);
// set options of object currently bound to GL_WINDOW_TARGET
glSetObjectOption(GL_WINDOW_TARGET, GL_OPTION_WINDOW_WIDTH,  800);
glSetObjectOption(GL_WINDOW_TARGET, GL_OPTION_WINDOW_HEIGHT, 600);
// set context target back to default
glBindObject(GL_WINDOW_TARGET, 0);
```

이 작은 코드 흐름은 OpenGL 작업 시 자주 보게 될 패턴입니다.
우선, 객체를 생성하고 그 객체를 참조할 수 있는 id로 저장합니다.
(실제 객체의 데이터는 내부적으로 저장됩니다.)
그 다음, 해당 id를 이용해 객체를 컨텍스트의 대상 위치(target location)에 바인딩합니다.
(예시에서의 윈도우 객체 대상 위치는 GL_WINDOW_TARGET이라는 값으로 정의되어 있습니다.)
그리고 나서, 윈도우의 옵션들을 설정하고, 작업이 끝난 뒤에는 해당 대상 위치의 객체 id를 0으로 설정하여 바인딩을 해제합니다.
우리가 설정한 옵션들은 objectId로 참조되는 객체 안에 저장되며,
해당 객체를 다시 GL_WINDOW_TARGET에 바인딩하면 이전에 저장된 옵션들이 복원됩니다.

> 지금까지 제공된 코드 예시는 실제 OpenGL의 동작 방식을 대략적으로 보여주는 것일 뿐입니다.
책을 따라가다 보면 실제 OpenGL 코드 예제들을 충분히 보게 될 것입니다.

이러한 객체 시스템의 큰 장점은,
애플리케이션 내에서 여러 개의 객체를 생성해 각각의 옵션을 따로 설정할 수 있다는 것입니다.
그리고 OpenGL 상태를 이용하는 작업을 시작할 때,
원하는 설정이 담긴 객체만 바인딩하면 됩니다.
예를 들어, 3D 모델 데이터(집, 캐릭터 등)를 담는 컨테이너 객체가 있을 수 있습니다.
우리가 특정 모델을 그릴 때, 해당 모델 데이터를 담고 있는 객체를 바인딩하면 됩니다.
(물론 사전에 해당 객체를 **생성하고 옵션을 설정해 두어야 합니다.)
여러 개의 객체를 사용하면 다양한 모델들을 미리 정의해 둘 수 있고,
특정 모델을 그릴 때마다 그에 해당하는 객체만 바인딩하면 되므로
옵션들을 매번 다시 설정할 필요가 없습니다.

## Let's get started

이제 여러분은 OpenGL의 명세와 라이브러리,
그리고 OpenGL이 내부적으로 어떻게 동작하는지에 대한 개략적인 내용,
그리고 OpenGL이 사용하는 몇 가지 특유의 기법들에 대해 배웠습니다.
아직 모든 내용을 완벽히 이해하지 못했더라도 걱정하지 마세요.
이 책을 따라가며 하나씩 차근차근 배워 나갈 것이고,
충분한 예제들을 통해 OpenGL에 대한 이해를 확실히 쌓을 수 있을 것입니다.